<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Straight AI</title>
</head>
<body style="margin:0; padding:0; font-family:sans-serif; background:#fafafa; color:#111;">
  <div style="text-align:center; margin-top:30vh;">
    <input id="question" type="text" placeholder="Ask..."
      style="width:80%; max-width:500px; font-size:18px; padding:6px; border:1px solid #ccc; border-radius:6px;">
  </div>

  <pre id="response" style="margin-top:40px; text-align:center; font-size:16px; white-space:pre-wrap; word-wrap:break-word;"></pre>
  <div id="footer" style="opacity:0; transition:opacity 0.8s; text-align:center; margin-top:50px; font-size:13px; color:#555;">
    Straight AI Â© 2025 â€“ No essays. Just answers.
  </div>

<script>
  const BACKEND_URL = "https://straight-ai.onrender.com"; // ðŸ”— your live backend

  const input = document.getElementById("question");
  const responseEl = document.getElementById("response");
  const footer = document.getElementById("footer");
  input.focus();

  let adminMode = false;
  let legalMode = false;
  let fundMode = false;
  let thinkingInterval = null;
  let cancelTyping = false;
  let activeRequest = 0;

  function startThinkingAnimation() {
    footer.style.opacity = 0;
    let dots = 1;
    responseEl.textContent = "Thinking.";
    thinkingInterval = setInterval(() => {
      dots = (dots % 3) + 1;
      responseEl.textContent = "Thinking" + ".".repeat(dots);
    }, 400);
  }

  function stopThinkingAnimation() {
    clearInterval(thinkingInterval);
    thinkingInterval = null;
  }

  async function typeOutText(text) {
    cancelTyping = false;
    responseEl.textContent = "";
    footer.style.opacity = 0;
    for (let i = 0; i < text.length; i++) {
      if (cancelTyping) return;
      responseEl.textContent += text[i];
      await new Promise(r => setTimeout(r, Math.max(5, 25 - i / 6)));
    }
    footer.style.opacity = 1;
  }

  const PRIVACY = `Straight AI Privacy Policy

Section I â€“ Introduction
Straight AI values privacy almost as much as simplicity. We answer your questions, not store them.

Section II â€“ Data Handling
Your questions go to OpenAI and vanish after your answer arrives.

Section III â€“ Cookies
We donâ€™t use cookies, pixels, or secret snacks.

Section IV â€“ Temporary Storage
Text lives briefly in memory, then is gone forever.

Section V â€“ Analytics
We only count anonymous totals to feel productive.

Section VI â€“ Encryption
Traffic is encrypted in transit. Nothing rests long enough to need it otherwise.

Section VII â€“ Personal Info
We never ask for personal details; if you volunteer them, the AI just nods politely.

Section VIII â€“ Hosting
Render provides the servers; their policy joins ours by default.

Section IX â€“ Updates
This policy may shrink further without notice.

Section X â€“ Microscopic Print
(:: Administrators may view search history solely to ensure proper tool use ::)
`;

  const TERMS = `Straight AI Terms of Service

Section I â€“ Acceptance
Using Straight AI means embracing concise chaos.

Section II â€“ Responsibility
Weâ€™re not responsible for what you do with short truths.

Section III â€“ Accuracy
Brevity beats correctness nine times out of ten.

Section IV â€“ Complexity
Ask too much and expect "Too complex."

Section V â€“ Limitations
We resist essays with heroic discipline.

Section VI â€“ Availability
Online today, gone tomorrowâ€”no refunds, no tears.

Section VII â€“ Conduct
Stay civil; the AI judges silently.

Section VIII â€“ Liability
If our answer ruins dinner conversation, thatâ€™s on you.

Section IX â€“ Humor Clause
Occasional sarcasm is intentional performance art.

Section X â€“ Support
Refresh the page. Thatâ€™s our helpdesk.

Section XI â€“ Legal Standing
We cannot appear in court or small claims.

Section XII â€“ Data
No storage, no ads, no creepy follow-ups.

Section XIII â€“ Revisions
We may edit these mid-sentence just because.

Section XIV â€“ Philosophy
Rule #1: Keep it short.

Section XV â€“ Final Statement
You have now agreed to everything and nothing simultaneously.
`;

  const FUND = `Straight AI Funding Portal

Section I â€“ Introduction
Welcome to the official Straight AI Funding Portal. We appreciate your desire to support us in spirit, if not in cash.

Section II â€“ Supported Methods
We accept all major credit cards, minor cards, imaginary currencies, and compliments.

Section III â€“ Crypto
Donations in StraightCoin, HonestToken, and AIthereum are highly encouraged, provided they don't exist.

Section IV â€“ Refund Policy
Refunds are impossible, because transactions never occur.

Section V â€“ Status
Please fill out the form below to send $0.00 to the void.
`;

  async function showLegal(text) {
    legalMode = true;
    fundMode = false;
    cancelTyping = true;
    stopThinkingAnimation();
    await new Promise(r => setTimeout(r, 50));
    window.scrollTo(0, 0);
    await typeOutText(text + "\n\n(Type 'back' to return)");
  }

  async function showFunding() {
    fundMode = true;
    responseEl.innerHTML =
      FUND.replace(/\n/g, "<br>") +
      '<br><br><input id="fundInput" type="text" placeholder="Enter $ amount (optional)" style="padding:5px; font-size:16px;">' +
      '<br><button id="fundBtn" style="margin-top:10px; padding:6px 12px; font-size:16px;">Send $0.00</button>';
    footer.style.opacity = 0;

    const btn = document.getElementById("fundBtn");
    btn.onclick = () => {
      const amount = document.getElementById("fundInput").value.trim() || "0.00";
      responseEl.innerHTML =
        `Processing transaction of $${amount}...<br><br><b>Transaction failed successfully.</b><br><br>(Type 'back' to return)`;
      fundMode = true;
    };
  }

  async function loadHistory() {
    cancelTyping = true;
    stopThinkingAnimation();
    try {
      const res = await fetch(`${BACKEND_URL}/history?code=1132025`);
      if (!res.ok) {
        responseEl.textContent = "Forbidden.";
        return;
      }
      const data = await res.json();
      responseEl.textContent = data.length
        ? data.map(e => `[${e.time}] ${e.question}`).join("\n")
        : "No history.";
    } catch {
      responseEl.textContent = "Server unreachable.";
    }
    footer.style.opacity = 1;
  }

  input.addEventListener("keydown", async e => {
    if (e.key !== "Enter") return;

    const question = input.value.trim();
    if (!question) return;

    cancelTyping = true;
    stopThinkingAnimation();
    const requestId = ++activeRequest;

    if ((legalMode || fundMode) && question.toLowerCase() === "back") {
      legalMode = false;
      fundMode = false;
      responseEl.textContent = "";
      input.value = "";
      footer.style.opacity = 0;
      return;
    }

    if (question === "1132025") {
      adminMode = !adminMode;
      responseEl.textContent = adminMode ? "Loading history..." : "";
      input.value = adminMode ? "Viewing history (type anything else to exit)" : "";
      footer.style.opacity = 0;
      if (adminMode) await loadHistory();
      return;
    }

    if (adminMode) {
      adminMode = false;
      responseEl.textContent = "";
      footer.style.opacity = 0;
    }

    const qLower = question.toLowerCase();
    if (qLower.includes("privacy policy")) return await showLegal(PRIVACY);
    if (qLower.includes("terms of service")) return await showLegal(TERMS);
    if (qLower.includes("fund") || qLower.includes("support")) return await showFunding();

    startThinkingAnimation();
    try {
      const res = await fetch(`${BACKEND_URL}/straight`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ question }),
      });
      const data = await res.json();

      if (requestId !== activeRequest) return;
      stopThinkingAnimation();
      await typeOutText(data.answer || "No response.");
    } catch {
      if (requestId !== activeRequest) return;
      stopThinkingAnimation();
      responseEl.textContent = "Server offline or unreachable.";
      footer.style.opacity = 1;
    }
  });

  input.addEventListener("focus", () => input.select());
</script>
